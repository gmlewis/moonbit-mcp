// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT
// Generated from: https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26

////////////////////////////////////////////////////////////////////////////////
// JSON-RPC types
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for Request with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Request with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("method") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for Notification with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Notification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("method") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { method_, params }
}

////////////////////////////////////////////////////////////////////////////////
// Empty result
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Cancellation
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CancelledNotificationParams with to_json(self) {
  let obj = {}
  obj["requestId"] = self.requestId.to_json()
  if self.reason is Some(v) {
    obj["reason"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CancelledNotificationParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("requestId") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'requestId'"))
  }
  let v : Result[@jsonrpc2.ID, _] = try? @json.from_json(json)
  guard v is Ok(requestId) else {
    raise @json.JsonDecodeError((path, "expected field 'requestId'"))
  }
  let reason : String? = match obj.get("reason") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { requestId, reason }
}

///|
pub impl ToJson for CancelledNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CancelledNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CancelledNotificationParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Initialization
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for InitializeRequestParams with to_json(self) {
  let obj = {}
  obj["protocolVersion"] = self.protocolVersion.to_json()
  obj["capabilities"] = self.capabilities.to_json()
  obj["clientInfo"] = self.clientInfo.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("protocolVersion") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(protocolVersion) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  guard obj.get("capabilities") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  let v : Result[ClientCapabilities, _] = try? @json.from_json(json)
  guard v is Ok(capabilities) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  guard obj.get("clientInfo") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'clientInfo'"))
  }
  let v : Result[Implementation, _] = try? @json.from_json(json)
  guard v is Ok(clientInfo) else {
    raise @json.JsonDecodeError((path, "expected field 'clientInfo'"))
  }
  { protocolVersion, capabilities, clientInfo }
}

///|
pub impl ToJson for InitializeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[InitializeRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for InitializeResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["protocolVersion"] = self.protocolVersion.to_json()
  obj["capabilities"] = self.capabilities.to_json()
  obj["serverInfo"] = self.serverInfo.to_json()
  if self.instructions is Some(v) {
    obj["instructions"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("protocolVersion") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(protocolVersion) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  guard obj.get("capabilities") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  let v : Result[ServerCapabilities, _] = try? @json.from_json(json)
  guard v is Ok(capabilities) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  guard obj.get("serverInfo") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'serverInfo'"))
  }
  let v : Result[Implementation, _] = try? @json.from_json(json)
  guard v is Ok(serverInfo) else {
    raise @json.JsonDecodeError((path, "expected field 'serverInfo'"))
  }
  let instructions : String? = match obj.get("instructions") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { _meta, protocolVersion, capabilities, serverInfo, instructions }
}

///|
pub impl ToJson for InitializedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializedNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ClientCapabilitiesRoots with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ClientCapabilitiesRoots with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj.get("listChanged") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ClientCapabilities with to_json(self) {
  let obj = {}
  if self.experimental is Some(v) {
    obj["experimental"] = v.to_json()
  }
  if self.roots is Some(v) {
    obj["roots"] = v.to_json()
  }
  if self.sampling is Some(v) {
    obj["sampling"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ClientCapabilities with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let experimental : Map[String, Json]? = match obj.get("experimental") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let roots : ClientCapabilitiesRoots? = match obj.get("roots") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let sampling : Map[String, Json]? = match obj.get("sampling") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { experimental, roots, sampling }
}

///|
pub impl ToJson for ServerCapabilitiesPrompts with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesPrompts with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj.get("listChanged") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ServerCapabilitiesResources with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  if self.subscribe is Some(v) {
    obj["subscribe"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesResources with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj.get("listChanged") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let subscribe : Bool? = match obj.get("subscribe") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { listChanged, subscribe }
}

///|
pub impl ToJson for ServerCapabilitiesTools with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesTools with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj.get("listChanged") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ServerCapabilities with to_json(self) {
  let obj = {}
  if self.experimental is Some(v) {
    obj["experimental"] = v.to_json()
  }
  if self.logging is Some(v) {
    obj["logging"] = v.to_json()
  }
  if self.completions is Some(v) {
    obj["completions"] = v.to_json()
  }
  if self.prompts is Some(v) {
    obj["prompts"] = v.to_json()
  }
  if self.resources is Some(v) {
    obj["resources"] = v.to_json()
  }
  if self.tools is Some(v) {
    obj["tools"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilities with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let experimental : Map[String, Json]? = match obj.get("experimental") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let logging : Map[String, Json]? = match obj.get("logging") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let completions : Map[String, Json]? = match obj.get("completions") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let prompts : ServerCapabilitiesPrompts? = match obj.get("prompts") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let resources : ServerCapabilitiesResources? = match obj.get("resources") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let tools : ServerCapabilitiesTools? = match obj.get("tools") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { experimental, logging, completions, prompts, resources, tools }
}

///|
pub impl ToJson for Implementation with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["version"] = self.version.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Implementation with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj.get("version") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'version'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(version) else {
    raise @json.JsonDecodeError((path, "expected field 'version'"))
  }
  { name, version }
}

////////////////////////////////////////////////////////////////////////////////
// Ping
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for PingRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PingRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Progress notifications
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ProgressNotificationParams with to_json(self) {
  let obj = {}
  obj["progress"] = self.progress.to_json()
  obj["progressToken"] = self.progressToken.to_json()
  if self.total is Some(v) {
    obj["total"] = v.to_json()
  }
  if self.message is Some(v) {
    obj["message"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ProgressNotificationParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("progress") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'progress'"))
  }
  let v : Result[Double, _] = try? @json.from_json(json)
  guard v is Ok(progress) else {
    raise @json.JsonDecodeError((path, "expected field 'progress'"))
  }
  guard obj.get("progressToken") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'progressToken'"))
  }
  let v : Result[ProgressToken, _] = try? @json.from_json(json)
  guard v is Ok(progressToken) else {
    raise @json.JsonDecodeError((path, "expected field 'progressToken'"))
  }
  let total : Double? = match obj.get("total") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let message : String? = match obj.get("message") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { progress, progressToken, total, message }
}

///|
pub impl ToJson for ProgressNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ProgressNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ProgressNotificationParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Pagination
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for PaginatedRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj.get("cursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for PaginatedRequest with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("method") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : PaginatedRequestParams? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for PaginatedResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let nextCursor : String? = match obj.get("nextCursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { _meta, nextCursor }
}

////////////////////////////////////////////////////////////////////////////////
// Resources
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListResourcesRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesRequestParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj.get("cursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListResourcesRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListResourcesRequestParams? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListResourcesResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["resources"] = self.resources.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let nextCursor : String? = match obj.get("nextCursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("resources") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resources'"))
  }
  let v : Result[Array[Resource], _] = try? @json.from_json(json)
  guard v is Ok(resources) else {
    raise @json.JsonDecodeError((path, "expected field 'resources'"))
  }
  { _meta, nextCursor, resources }
}

///|
pub impl ToJson for ListResourceTemplatesRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesRequestParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj.get("cursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListResourceTemplatesRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesRequest with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListResourceTemplatesRequestParams? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListResourceTemplatesResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["resourceTemplates"] = self.resourceTemplates.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesResult with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let nextCursor : String? = match obj.get("nextCursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("resourceTemplates") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resourceTemplates'"))
  }
  let v : Result[Array[ResourceTemplate], _] = try? @json.from_json(json)
  guard v is Ok(resourceTemplates) else {
    raise @json.JsonDecodeError((path, "expected field 'resourceTemplates'"))
  }
  { _meta, nextCursor, resourceTemplates }
}

///|
pub impl ToJson for ReadResourceRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for ReadResourceRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ReadResourceRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ReadResourceResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["contents"] = self.contents.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("contents") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'contents'"))
  }
  let v : Result[Array[&ReadResourceResultContents], _] = try? @json.from_json(
      json,
    )
  guard v is Ok(contents) else {
    raise @json.JsonDecodeError((path, "expected field 'contents'"))
  }
  { _meta, contents }
}

///|
pub impl ToJson for ResourceListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceListChangedNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for SubscribeRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SubscribeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for SubscribeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SubscribeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[SubscribeRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for UnsubscribeRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for UnsubscribeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for UnsubscribeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for UnsubscribeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[UnsubscribeRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ResourceUpdatedNotificationParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceUpdatedNotificationParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for ResourceUpdatedNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceUpdatedNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ResourceUpdatedNotificationParams, _] = try? @json.from_json(
      json,
    )
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for Resource with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj["name"] = self.name.to_json()
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  if self.size is Some(v) {
    obj["size"] = v.to_double().to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Resource with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let mimeType : String? = match obj.get("mimeType") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let size : Int64? = match obj.get("size") {
    Some(v) =>
      match v {
        Number(v) => Some(v.to_int64())
        _ => raise @json.JsonDecodeError((path, "expected number; got \{v}"))
      }
    None => None
  }
  { uri, name, description, mimeType, annotations, size }
}

///|
pub impl ToJson for ResourceTemplate with to_json(self) {
  let obj = {}
  obj["uriTemplate"] = self.uriTemplate.to_json()
  obj["name"] = self.name.to_json()
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceTemplate with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uriTemplate") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uriTemplate'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uriTemplate) else {
    raise @json.JsonDecodeError((path, "expected field 'uriTemplate'"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let mimeType : String? = match obj.get("mimeType") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { uriTemplate, name, description, mimeType, annotations }
}

///|
pub impl ToJson for ResourceContents with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let mimeType : String? = match obj.get("mimeType") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { uri, mimeType }
}

///|
pub impl ToJson for TextResourceContents with to_json(self) {
  let obj = {}
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj["text"] = self.text.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for TextResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let mimeType : String? = match obj.get("mimeType") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  guard obj.get("text") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(text) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  { mimeType, uri, text }
}

///|
pub impl ToJson for BlobResourceContents with to_json(self) {
  let obj = {}
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj["blob"] = self.blob.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for BlobResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let mimeType : String? = match obj.get("mimeType") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  guard obj.get("blob") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'blob'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(blob) else {
    raise @json.JsonDecodeError((path, "expected field 'blob'"))
  }
  { mimeType, uri, blob }
}

////////////////////////////////////////////////////////////////////////////////
// Prompts
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListPromptsRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj.get("cursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListPromptsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListPromptsRequestParams? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListPromptsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["prompts"] = self.prompts.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let nextCursor : String? = match obj.get("nextCursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("prompts") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'prompts'"))
  }
  let v : Result[Array[Prompt], _] = try? @json.from_json(json)
  guard v is Ok(prompts) else {
    raise @json.JsonDecodeError((path, "expected field 'prompts'"))
  }
  { _meta, nextCursor, prompts }
}

///|
pub impl ToJson for GetPromptRequestParams with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let arguments : Map[String, String]? = match obj.get("arguments") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, arguments }
}

///|
pub impl ToJson for GetPromptRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[GetPromptRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for GetPromptResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["messages"] = self.messages.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("messages") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let v : Result[Array[PromptMessage], _] = try? @json.from_json(json)
  guard v is Ok(messages) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  { _meta, description, messages }
}

///|
pub impl ToJson for Prompt with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Prompt with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let arguments : Array[PromptArgument]? = match obj.get("arguments") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, description, arguments }
}

///|
pub impl ToJson for PromptArgument with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.required is Some(v) {
    obj["required"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptArgument with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let required : Bool? = match obj.get("required") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, description, required }
}

///|
pub impl ToJson for PromptMessage with to_json(self) {
  let obj = {}
  obj["role"] = self.role.to_json()
  obj["content"] = self.content.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptMessage with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("role") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = try? @json.from_json(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  guard obj.get("content") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&PromptMessageContent, _] = try? @json.from_json(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  { role, content }
}

///|
pub impl ToJson for EmbeddedResource with to_json(self) {
  let obj = {}
  obj["type"] = "resource".to_json()
  obj["resource"] = self.resource.to_json()
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for EmbeddedResource with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='resource'"))
  }
  guard obj.get("resource") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  let v : Result[&EmbeddedResourceResource, _] = try? @json.from_json(json)
  guard v is Ok(resource) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { resource, annotations }
}

///|
pub impl ToJson for PromptListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptListChangedNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Tools
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListToolsRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj.get("cursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListToolsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListToolsRequestParams? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListToolsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["tools"] = self.tools.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let nextCursor : String? = match obj.get("nextCursor") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("tools") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'tools'"))
  }
  let v : Result[Array[Tool], _] = try? @json.from_json(json)
  guard v is Ok(tools) else {
    raise @json.JsonDecodeError((path, "expected field 'tools'"))
  }
  { _meta, nextCursor, tools }
}

///|
pub impl ToJson for CallToolResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["content"] = self.content.to_json()
  if self.isError is Some(v) {
    obj["isError"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("content") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[Array[&CallToolResultContent], _] = try? @json.from_json(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let isError : Bool? = match obj.get("isError") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { _meta, content, isError }
}

///|
pub impl ToJson for CallToolRequestParams with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let arguments : Map[String, Json]? = match obj.get("arguments") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, arguments }
}

///|
pub impl ToJson for CallToolRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CallToolRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ToolListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolListChangedNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ToolAnnotations with to_json(self) {
  let obj = {}
  if self.title is Some(v) {
    obj["title"] = v.to_json()
  }
  if self.readOnlyHint is Some(v) {
    obj["readOnlyHint"] = v.to_json()
  }
  if self.destructiveHint is Some(v) {
    obj["destructiveHint"] = v.to_json()
  }
  if self.idempotentHint is Some(v) {
    obj["idempotentHint"] = v.to_json()
  }
  if self.openWorldHint is Some(v) {
    obj["openWorldHint"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolAnnotations with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let title : String? = match obj.get("title") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let readOnlyHint : Bool? = match obj.get("readOnlyHint") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let destructiveHint : Bool? = match obj.get("destructiveHint") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let idempotentHint : Bool? = match obj.get("idempotentHint") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let openWorldHint : Bool? = match obj.get("openWorldHint") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { title, readOnlyHint, destructiveHint, idempotentHint, openWorldHint }
}

///|
pub impl ToJson for ToolInputSchema with to_json(self) {
  let obj = {}
  obj["type"] = "object".to_json()
  if self.properties is Some(v) {
    obj["properties"] = v.to_json()
  }
  if self.required is Some(v) {
    obj["required"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolInputSchema with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("object")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='object'"))
  }
  let properties : Map[String, Json]? = match obj.get("properties") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let required : Array[String]? = match obj.get("required") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { properties, required }
}

///|
pub impl ToJson for Tool with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["inputSchema"] = self.inputSchema.to_json()
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Tool with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let description : String? = match obj.get("description") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("inputSchema") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'inputSchema'"))
  }
  let v : Result[ToolInputSchema, _] = try? @json.from_json(json)
  guard v is Ok(inputSchema) else {
    raise @json.JsonDecodeError((path, "expected field 'inputSchema'"))
  }
  let annotations : ToolAnnotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, description, inputSchema, annotations }
}

////////////////////////////////////////////////////////////////////////////////
// Logging
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for SetLevelRequestParams with to_json(self) {
  let obj = {}
  obj["level"] = self.level.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SetLevelRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("level") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let v : Result[LoggingLevel, _] = try? @json.from_json(json)
  guard v is Ok(level) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  { level, }
}

///|
pub impl ToJson for SetLevelRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SetLevelRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[SetLevelRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for LoggingMessageNotificationParams with to_json(self) {
  let obj = {}
  obj["level"] = self.level.to_json()
  if self.logger is Some(v) {
    obj["logger"] = v.to_json()
  }
  obj["data"] = self.data.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for LoggingMessageNotificationParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("level") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let v : Result[LoggingLevel, _] = try? @json.from_json(json)
  guard v is Ok(level) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let logger : String? = match obj.get("logger") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("data") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[Json, _] = try? @json.from_json(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  { level, logger, data }
}

///|
pub impl ToJson for LoggingMessageNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for LoggingMessageNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[LoggingMessageNotificationParams, _] = try? @json.from_json(
      json,
    )
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Sampling
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CreateMessageRequestParams with to_json(self) {
  let obj = {}
  obj["messages"] = self.messages.to_json()
  if self.modelPreferences is Some(v) {
    obj["modelPreferences"] = v.to_json()
  }
  if self.systemPrompt is Some(v) {
    obj["systemPrompt"] = v.to_json()
  }
  if self.includeContext is Some(v) {
    obj["includeContext"] = v.to_json()
  }
  if self.temperature is Some(v) {
    obj["temperature"] = v.to_json()
  }
  obj["maxTokens"] = self.maxTokens.to_json()
  if self.stopSequences is Some(v) {
    obj["stopSequences"] = v.to_json()
  }
  if self.metadata is Some(v) {
    obj["metadata"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageRequestParams with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("messages") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let v : Result[Array[SamplingMessage], _] = try? @json.from_json(json)
  guard v is Ok(messages) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let modelPreferences : ModelPreferences? = match obj.get("modelPreferences") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let systemPrompt : String? = match obj.get("systemPrompt") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let includeContext : IncludeContext? = match obj.get("includeContext") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let temperature : Double? = match obj.get("temperature") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("maxTokens") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'maxTokens'"))
  }
  let v : Result[Int64, _] = try? @json.from_json(json)
  guard v is Ok(maxTokens) else {
    raise @json.JsonDecodeError((path, "expected field 'maxTokens'"))
  }
  let stopSequences : Array[String]? = match obj.get("stopSequences") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let metadata : Map[String, Json]? = match obj.get("metadata") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  {
    messages,
    modelPreferences,
    systemPrompt,
    includeContext,
    temperature,
    maxTokens,
    stopSequences,
    metadata,
  }
}

///|
pub impl ToJson for CreateMessageRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CreateMessageRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for CreateMessageResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["content"] = self.content.to_json()
  obj["role"] = self.role.to_json()
  obj["model"] = self.model.to_json()
  if self.stopReason is Some(v) {
    obj["stopReason"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("content") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&CreateMessageResultContent, _] = try? @json.from_json(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  guard obj.get("role") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = try? @json.from_json(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  guard obj.get("model") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'model'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(model) else {
    raise @json.JsonDecodeError((path, "expected field 'model'"))
  }
  let stopReason : String? = match obj.get("stopReason") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { _meta, content, role, model, stopReason }
}

///|
pub impl ToJson for SamplingMessage with to_json(self) {
  let obj = {}
  obj["role"] = self.role.to_json()
  obj["content"] = self.content.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SamplingMessage with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("role") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = try? @json.from_json(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  guard obj.get("content") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&SamplingMessageContent, _] = try? @json.from_json(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  { role, content }
}

///|
pub impl ToJson for Annotations with to_json(self) {
  let obj = {}
  if self.audience is Some(v) {
    obj["audience"] = v.to_json()
  }
  if self.priority is Some(v) {
    obj["priority"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Annotations with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let audience : Array[Role]? = match obj.get("audience") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let priority : Double? = match obj.get("priority") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { audience, priority }
}

///|
pub impl ToJson for TextContent with to_json(self) {
  let obj = {}
  obj["type"] = "text".to_json()
  obj["text"] = self.text.to_json()
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for TextContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("text")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='text'"))
  }
  guard obj.get("text") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(text) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { text, annotations }
}

///|
pub impl ToJson for ImageContent with to_json(self) {
  let obj = {}
  obj["type"] = "image".to_json()
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ImageContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("image")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='image'"))
  }
  guard obj.get("data") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj.get("mimeType") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { data, mimeType, annotations }
}

///|
pub impl ToJson for AudioContent with to_json(self) {
  let obj = {}
  obj["type"] = "audio".to_json()
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for AudioContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("audio")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='audio'"))
  }
  guard obj.get("data") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj.get("mimeType") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let annotations : Annotations? = match obj.get("annotations") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { data, mimeType, annotations }
}

///|
pub impl ToJson for ModelPreferences with to_json(self) {
  let obj = {}
  if self.hints is Some(v) {
    obj["hints"] = v.to_json()
  }
  if self.costPriority is Some(v) {
    obj["costPriority"] = v.to_json()
  }
  if self.speedPriority is Some(v) {
    obj["speedPriority"] = v.to_json()
  }
  if self.intelligencePriority is Some(v) {
    obj["intelligencePriority"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ModelPreferences with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let hints : Array[ModelHint]? = match obj.get("hints") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let costPriority : Double? = match obj.get("costPriority") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let speedPriority : Double? = match obj.get("speedPriority") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  let intelligencePriority : Double? = match obj.get("intelligencePriority") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { hints, costPriority, speedPriority, intelligencePriority }
}

///|
pub impl ToJson for ModelHint with to_json(self) {
  let obj = {}
  if self.name is Some(v) {
    obj["name"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ModelHint with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let name : String? = match obj.get("name") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { name, }
}

////////////////////////////////////////////////////////////////////////////////
// Autocomplete
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CompleteRequestParamsArgument with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["value"] = self.value.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequestParamsArgument with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj.get("value") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'value'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(value) else {
    raise @json.JsonDecodeError((path, "expected field 'value'"))
  }
  { name, value }
}

///|
pub impl ToJson for CompleteRequestParams with to_json(self) {
  let obj = {}
  obj["ref"] = self.ref_.to_json()
  obj["argument"] = self.argument.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("ref") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  let v : Result[&CompleteRequestParamsRef, _] = try? @json.from_json(json)
  guard v is Ok(ref_) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  guard obj.get("argument") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  let v : Result[CompleteRequestParamsArgument, _] = try? @json.from_json(json)
  guard v is Ok(argument) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  { ref_, argument }
}

///|
pub impl ToJson for CompleteRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("params") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CompleteRequestParams, _] = try? @json.from_json(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for CompleteResultCompletion with to_json(self) {
  let obj = {}
  obj["values"] = self.values.to_json()
  if self.total is Some(v) {
    obj["total"] = v.to_double().to_json()
  }
  if self.hasMore is Some(v) {
    obj["hasMore"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteResultCompletion with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("values") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'values'"))
  }
  let v : Result[Array[String], _] = try? @json.from_json(json)
  guard v is Ok(values) else {
    raise @json.JsonDecodeError((path, "expected field 'values'"))
  }
  let total : Int64? = match obj.get("total") {
    Some(v) =>
      match v {
        Number(v) => Some(v.to_int64())
        _ => raise @json.JsonDecodeError((path, "expected number; got \{v}"))
      }
    None => None
  }
  let hasMore : Bool? = match obj.get("hasMore") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { values, total, hasMore }
}

///|
pub impl ToJson for CompleteResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["completion"] = self.completion.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("completion") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'completion'"))
  }
  let v : Result[CompleteResultCompletion, _] = try? @json.from_json(json)
  guard v is Ok(completion) else {
    raise @json.JsonDecodeError((path, "expected field 'completion'"))
  }
  { _meta, completion }
}

///|
pub impl ToJson for ResourceReference with to_json(self) {
  let obj = {}
  obj["type"] = "ref/resource".to_json()
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("ref/resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/resource'"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for PromptReference with to_json(self) {
  let obj = {}
  obj["type"] = "ref/prompt".to_json()
  obj["name"] = self.name.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("type") == Some(Json::string("ref/prompt")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/prompt'"))
  }
  guard obj.get("name") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  { name, }
}

////////////////////////////////////////////////////////////////////////////////
// Roots
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListRootsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListRootsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListRootsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["roots"] = self.roots.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListRootsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj.get("_meta") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  guard obj.get("roots") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'roots'"))
  }
  let v : Result[Array[Root], _] = try? @json.from_json(json)
  guard v is Ok(roots) else {
    raise @json.JsonDecodeError((path, "expected field 'roots'"))
  }
  { _meta, roots }
}

///|
pub impl ToJson for Root with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  if self.name is Some(v) {
    obj["name"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Root with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj.get("uri") is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = try? @json.from_json(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let name : String? = match obj.get("name") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { uri, name }
}

///|
pub impl ToJson for RootsListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for RootsListChangedNotification with from_json(
  json,
  path,
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj.get("params") {
    Some(v) => {
      let v = try? @json.from_json(v)
      match v {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Client messages
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Server messages
////////////////////////////////////////////////////////////////////////////////
