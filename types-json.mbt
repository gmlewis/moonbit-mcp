// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT

///|
pub impl ToJson for AudioContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  obj["type"] = "audio".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for AudioContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["data"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj["mimeType"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  guard obj["type"] == Some(String("audio")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='audio'"))
  }
  { annotations, data, mimeType }
}

///|
pub impl ToJson for CompleteRequestParams with to_json(self) {
  let obj = {}
  obj["argument"] = self.argument.to_json()
  obj["ref"] = self.ref_.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["argument"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  let v : Result[CompleteRequestParamsArgument, _] = @json.from_json?(json)
  guard v is Ok(argument) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  guard obj["ref"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  let v : Result[CompleteRequestParamsRef, _] = @json.from_json?(json)
  guard v is Ok(ref_) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  { argument, ref_ }
}

///|
pub impl ToJson for EmbeddedResource with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["resource"] = self.resource.to_json()
  obj["type"] = "resource".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for EmbeddedResource with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["resource"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  let v : Result[EmbeddedResourceResource, _] = @json.from_json?(json)
  guard v is Ok(resource) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  guard obj["type"] == Some(String("resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='resource'"))
  }
  { annotations, resource }
}

///|
pub impl ToJson for ImageContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  obj["type"] = "image".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ImageContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["data"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj["mimeType"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  guard obj["type"] == Some(String("image")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='image'"))
  }
  { annotations, data, mimeType }
}

///|
pub impl ToJson for Notification with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Notification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : NotificationParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for PaginatedRequest with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : PaginatedRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for PromptReference with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["type"] = "ref/prompt".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj["type"] == Some(String("ref/prompt")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/prompt'"))
  }
  { name, }
}

///|
pub impl ToJson for Request with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Request with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : RequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for ResourceReference with to_json(self) {
  let obj = {}
  obj["type"] = "ref/resource".to_json()
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["type"] == Some(String("ref/resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/resource'"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for TextContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["text"] = self.text.to_json()
  obj["type"] = "text".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for TextContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["text"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(text) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  guard obj["type"] == Some(String("text")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='text'"))
  }
  { annotations, text }
}

///|
pub impl ToJson for ToolInputSchema with to_json(self) {
  let obj = {}
  if self.properties is Some(v) {
    obj["properties"] = v.to_json()
  }
  if self.required is Some(v) {
    obj["required"] = v.to_json()
  }
  obj["type"] = "object".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolInputSchema with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let properties : Json? = match obj["properties"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let required : Array[String]? = match obj["required"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["type"] == Some(String("object")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='object'"))
  }
  { properties, required }
}
