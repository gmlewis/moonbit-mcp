// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT
// Generated from: https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26

////////////////////////////////////////////////////////////////////////////////
// JSON-RPC types
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for Request with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Request with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for Notification with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Notification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

////////////////////////////////////////////////////////////////////////////////
// Empty result
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Cancellation
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CancelledNotificationParams with to_json(self) {
  let obj = {}
  if self.reason is Some(v) {
    obj["reason"] = v.to_json()
  }
  obj["requestId"] = self.requestId.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CancelledNotificationParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let reason : String? = match obj["reason"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["requestId"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'requestId'"))
  }
  let v : Result[@jsonrpc2.ID, _] = @json.from_json?(json)
  guard v is Ok(requestId) else {
    raise @json.JsonDecodeError((path, "expected field 'requestId'"))
  }
  { reason, requestId }
}

///|
pub impl ToJson for CancelledNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CancelledNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CancelledNotificationParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Initialization
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for InitializeRequestParams with to_json(self) {
  let obj = {}
  obj["capabilities"] = self.capabilities.to_json()
  obj["clientInfo"] = self.clientInfo.to_json()
  obj["protocolVersion"] = self.protocolVersion.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["capabilities"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  let v : Result[ClientCapabilities, _] = @json.from_json?(json)
  guard v is Ok(capabilities) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  guard obj["clientInfo"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'clientInfo'"))
  }
  let v : Result[Implementation, _] = @json.from_json?(json)
  guard v is Ok(clientInfo) else {
    raise @json.JsonDecodeError((path, "expected field 'clientInfo'"))
  }
  guard obj["protocolVersion"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(protocolVersion) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  { capabilities, clientInfo, protocolVersion }
}

///|
pub impl ToJson for InitializeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[InitializeRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for InitializeResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["capabilities"] = self.capabilities.to_json()
  if self.instructions is Some(v) {
    obj["instructions"] = v.to_json()
  }
  obj["protocolVersion"] = self.protocolVersion.to_json()
  obj["serverInfo"] = self.serverInfo.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializeResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["capabilities"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  let v : Result[ServerCapabilities, _] = @json.from_json?(json)
  guard v is Ok(capabilities) else {
    raise @json.JsonDecodeError((path, "expected field 'capabilities'"))
  }
  let instructions : String? = match obj["instructions"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["protocolVersion"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(protocolVersion) else {
    raise @json.JsonDecodeError((path, "expected field 'protocolVersion'"))
  }
  guard obj["serverInfo"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'serverInfo'"))
  }
  let v : Result[Implementation, _] = @json.from_json?(json)
  guard v is Ok(serverInfo) else {
    raise @json.JsonDecodeError((path, "expected field 'serverInfo'"))
  }
  { _meta, capabilities, instructions, protocolVersion, serverInfo }
}

///|
pub impl ToJson for InitializedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for InitializedNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ClientCapabilitiesRoots with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ClientCapabilitiesRoots with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj["listChanged"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ClientCapabilities with to_json(self) {
  let obj = {}
  if self.experimental is Some(v) {
    obj["experimental"] = v.to_json()
  }
  if self.roots is Some(v) {
    obj["roots"] = v.to_json()
  }
  if self.sampling is Some(v) {
    obj["sampling"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ClientCapabilities with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let experimental : Map[String, Json]? = match obj["experimental"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let roots : ClientCapabilitiesRoots? = match obj["roots"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let sampling : Map[String, Json]? = match obj["sampling"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { experimental, roots, sampling }
}

///|
pub impl ToJson for ServerCapabilitiesPrompts with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesPrompts with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj["listChanged"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ServerCapabilitiesResources with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  if self.subscribe is Some(v) {
    obj["subscribe"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesResources with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj["listChanged"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let subscribe : Bool? = match obj["subscribe"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { listChanged, subscribe }
}

///|
pub impl ToJson for ServerCapabilitiesTools with to_json(self) {
  let obj = {}
  if self.listChanged is Some(v) {
    obj["listChanged"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilitiesTools with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let listChanged : Bool? = match obj["listChanged"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { listChanged, }
}

///|
pub impl ToJson for ServerCapabilities with to_json(self) {
  let obj = {}
  if self.completions is Some(v) {
    obj["completions"] = v.to_json()
  }
  if self.experimental is Some(v) {
    obj["experimental"] = v.to_json()
  }
  if self.logging is Some(v) {
    obj["logging"] = v.to_json()
  }
  if self.prompts is Some(v) {
    obj["prompts"] = v.to_json()
  }
  if self.resources is Some(v) {
    obj["resources"] = v.to_json()
  }
  if self.tools is Some(v) {
    obj["tools"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ServerCapabilities with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let completions : Map[String, Json]? = match obj["completions"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let experimental : Map[String, Json]? = match obj["experimental"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let logging : Map[String, Json]? = match obj["logging"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let prompts : ServerCapabilitiesPrompts? = match obj["prompts"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let resources : ServerCapabilitiesResources? = match obj["resources"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let tools : ServerCapabilitiesTools? = match obj["tools"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { completions, experimental, logging, prompts, resources, tools }
}

///|
pub impl ToJson for Implementation with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["version"] = self.version.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Implementation with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj["version"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'version'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(version) else {
    raise @json.JsonDecodeError((path, "expected field 'version'"))
  }
  { name, version }
}

////////////////////////////////////////////////////////////////////////////////
// Ping
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for PingRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PingRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Progress notifications
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ProgressNotificationParams with to_json(self) {
  let obj = {}
  if self.message is Some(v) {
    obj["message"] = v.to_json()
  }
  obj["progress"] = self.progress.to_json()
  obj["progressToken"] = self.progressToken.to_json()
  if self.total is Some(v) {
    obj["total"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ProgressNotificationParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let message : String? = match obj["message"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["progress"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'progress'"))
  }
  let v : Result[Double, _] = @json.from_json?(json)
  guard v is Ok(progress) else {
    raise @json.JsonDecodeError((path, "expected field 'progress'"))
  }
  guard obj["progressToken"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'progressToken'"))
  }
  let v : Result[ProgressToken, _] = @json.from_json?(json)
  guard v is Ok(progressToken) else {
    raise @json.JsonDecodeError((path, "expected field 'progressToken'"))
  }
  let total : Double? = match obj["total"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { message, progress, progressToken, total }
}

///|
pub impl ToJson for ProgressNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ProgressNotification with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ProgressNotificationParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Pagination
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for PaginatedRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj["cursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for PaginatedRequest with to_json(self) {
  let obj = {}
  obj["method"] = self.method_.to_json()
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["method"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(method_) else {
    raise @json.JsonDecodeError((path, "expected field 'method'"))
  }
  let params : PaginatedRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { method_, params }
}

///|
pub impl ToJson for PaginatedResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PaginatedResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let nextCursor : String? = match obj["nextCursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { _meta, nextCursor }
}

////////////////////////////////////////////////////////////////////////////////
// Resources
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListResourcesRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesRequestParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj["cursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListResourcesRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListResourcesRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListResourcesResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["resources"] = self.resources.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourcesResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let nextCursor : String? = match obj["nextCursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["resources"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resources'"))
  }
  let v : Result[Array[Resource], _] = @json.from_json?(json)
  guard v is Ok(resources) else {
    raise @json.JsonDecodeError((path, "expected field 'resources'"))
  }
  { _meta, nextCursor, resources }
}

///|
pub impl ToJson for ListResourceTemplatesRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesRequestParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj["cursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListResourceTemplatesRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesRequest with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListResourceTemplatesRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListResourceTemplatesResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["resourceTemplates"] = self.resourceTemplates.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListResourceTemplatesResult with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let nextCursor : String? = match obj["nextCursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["resourceTemplates"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resourceTemplates'"))
  }
  let v : Result[Array[ResourceTemplate], _] = @json.from_json?(json)
  guard v is Ok(resourceTemplates) else {
    raise @json.JsonDecodeError((path, "expected field 'resourceTemplates'"))
  }
  { _meta, nextCursor, resourceTemplates }
}

///|
pub impl ToJson for ReadResourceRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for ReadResourceRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ReadResourceRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ReadResourceResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["contents"] = self.contents.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ReadResourceResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["contents"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'contents'"))
  }
  let v : Result[Array[&ReadResourceResultContents], _] = @json.from_json?(json)
  guard v is Ok(contents) else {
    raise @json.JsonDecodeError((path, "expected field 'contents'"))
  }
  { _meta, contents }
}

///|
pub impl ToJson for ResourceListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceListChangedNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for SubscribeRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SubscribeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for SubscribeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SubscribeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[SubscribeRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for UnsubscribeRequestParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for UnsubscribeRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for UnsubscribeRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for UnsubscribeRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[UnsubscribeRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ResourceUpdatedNotificationParams with to_json(self) {
  let obj = {}
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceUpdatedNotificationParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for ResourceUpdatedNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceUpdatedNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[ResourceUpdatedNotificationParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for Resource with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  if self.size is Some(v) {
    obj["size"] = v.to_double().to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Resource with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let mimeType : String? = match obj["mimeType"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let size : Int64? = match obj["size"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(Number(v)) => Some(v.to_int64())
        _ => raise @json.JsonDecodeError((path, "expected number; got \{v}"))
      }
    None => None
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { annotations, description, mimeType, name, size, uri }
}

///|
pub impl ToJson for ResourceTemplate with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  obj["uriTemplate"] = self.uriTemplate.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceTemplate with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let mimeType : String? = match obj["mimeType"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj["uriTemplate"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uriTemplate'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uriTemplate) else {
    raise @json.JsonDecodeError((path, "expected field 'uriTemplate'"))
  }
  { annotations, description, mimeType, name, uriTemplate }
}

///|
pub impl ToJson for ResourceContents with to_json(self) {
  let obj = {}
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let mimeType : String? = match obj["mimeType"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { mimeType, uri }
}

///|
pub impl ToJson for TextResourceContents with to_json(self) {
  let obj = {}
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["text"] = self.text.to_json()
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for TextResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let mimeType : String? = match obj["mimeType"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["text"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(text) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { mimeType, text, uri }
}

///|
pub impl ToJson for BlobResourceContents with to_json(self) {
  let obj = {}
  obj["blob"] = self.blob.to_json()
  if self.mimeType is Some(v) {
    obj["mimeType"] = v.to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for BlobResourceContents with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["blob"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'blob'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(blob) else {
    raise @json.JsonDecodeError((path, "expected field 'blob'"))
  }
  let mimeType : String? = match obj["mimeType"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { blob, mimeType, uri }
}

////////////////////////////////////////////////////////////////////////////////
// Prompts
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListPromptsRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj["cursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListPromptsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListPromptsRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListPromptsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["prompts"] = self.prompts.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListPromptsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let nextCursor : String? = match obj["nextCursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["prompts"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'prompts'"))
  }
  let v : Result[Array[Prompt], _] = @json.from_json?(json)
  guard v is Ok(prompts) else {
    raise @json.JsonDecodeError((path, "expected field 'prompts'"))
  }
  { _meta, nextCursor, prompts }
}

///|
pub impl ToJson for GetPromptRequestParams with to_json(self) {
  let obj = {}
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let arguments : Map[String, String]? = match obj["arguments"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  { arguments, name }
}

///|
pub impl ToJson for GetPromptRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[GetPromptRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for GetPromptResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["messages"] = self.messages.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for GetPromptResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["messages"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let v : Result[Array[PromptMessage], _] = @json.from_json?(json)
  guard v is Ok(messages) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  { _meta, description, messages }
}

///|
pub impl ToJson for Prompt with to_json(self) {
  let obj = {}
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Prompt with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let arguments : Array[PromptArgument]? = match obj["arguments"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  { arguments, description, name }
}

///|
pub impl ToJson for PromptArgument with to_json(self) {
  let obj = {}
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  if self.required is Some(v) {
    obj["required"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptArgument with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let required : Bool? = match obj["required"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { description, name, required }
}

///|
pub impl ToJson for PromptMessage with to_json(self) {
  let obj = {}
  obj["content"] = self.content.to_json()
  obj["role"] = self.role.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptMessage with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["content"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&PromptMessageContent, _] = @json.from_json?(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  guard obj["role"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = @json.from_json?(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  { content, role }
}

///|
pub impl ToJson for EmbeddedResource with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["resource"] = self.resource.to_json()
  obj["type"] = "resource".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for EmbeddedResource with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["resource"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  let v : Result[&EmbeddedResourceResource, _] = @json.from_json?(json)
  guard v is Ok(resource) else {
    raise @json.JsonDecodeError((path, "expected field 'resource'"))
  }
  guard obj["type"] == Some(String("resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='resource'"))
  }
  { annotations, resource }
}

///|
pub impl ToJson for PromptListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptListChangedNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Tools
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListToolsRequestParams with to_json(self) {
  let obj = {}
  if self.cursor is Some(v) {
    obj["cursor"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let cursor : String? = match obj["cursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { cursor, }
}

///|
pub impl ToJson for ListToolsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : ListToolsRequestParams? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListToolsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  if self.nextCursor is Some(v) {
    obj["nextCursor"] = v.to_json()
  }
  obj["tools"] = self.tools.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListToolsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let nextCursor : String? = match obj["nextCursor"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["tools"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'tools'"))
  }
  let v : Result[Array[Tool], _] = @json.from_json?(json)
  guard v is Ok(tools) else {
    raise @json.JsonDecodeError((path, "expected field 'tools'"))
  }
  { _meta, nextCursor, tools }
}

///|
pub impl ToJson for CallToolResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["content"] = self.content.to_json()
  if self.isError is Some(v) {
    obj["isError"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["content"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[Array[&CallToolResultContent], _] = @json.from_json?(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let isError : Bool? = match obj["isError"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { _meta, content, isError }
}

///|
pub impl ToJson for CallToolRequestParams with to_json(self) {
  let obj = {}
  if self.arguments is Some(v) {
    obj["arguments"] = v.to_json()
  }
  obj["name"] = self.name.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let arguments : Map[String, Json]? = match obj["arguments"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  { arguments, name }
}

///|
pub impl ToJson for CallToolRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CallToolRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CallToolRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for ToolListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolListChangedNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ToolAnnotations with to_json(self) {
  let obj = {}
  if self.destructiveHint is Some(v) {
    obj["destructiveHint"] = v.to_json()
  }
  if self.idempotentHint is Some(v) {
    obj["idempotentHint"] = v.to_json()
  }
  if self.openWorldHint is Some(v) {
    obj["openWorldHint"] = v.to_json()
  }
  if self.readOnlyHint is Some(v) {
    obj["readOnlyHint"] = v.to_json()
  }
  if self.title is Some(v) {
    obj["title"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolAnnotations with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let destructiveHint : Bool? = match obj["destructiveHint"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let idempotentHint : Bool? = match obj["idempotentHint"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let openWorldHint : Bool? = match obj["openWorldHint"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let readOnlyHint : Bool? = match obj["readOnlyHint"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let title : String? = match obj["title"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { destructiveHint, idempotentHint, openWorldHint, readOnlyHint, title }
}

///|
pub impl ToJson for ToolInputSchema with to_json(self) {
  let obj = {}
  if self.properties is Some(v) {
    obj["properties"] = v.to_json()
  }
  if self.required is Some(v) {
    obj["required"] = v.to_json()
  }
  obj["type"] = "object".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ToolInputSchema with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let properties : Map[String, Json]? = match obj["properties"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let required : Array[String]? = match obj["required"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["type"] == Some(String("object")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='object'"))
  }
  { properties, required }
}

///|
pub impl ToJson for Tool with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  if self.description is Some(v) {
    obj["description"] = v.to_json()
  }
  obj["inputSchema"] = self.inputSchema.to_json()
  obj["name"] = self.name.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Tool with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : ToolAnnotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let description : String? = match obj["description"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["inputSchema"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'inputSchema'"))
  }
  let v : Result[ToolInputSchema, _] = @json.from_json?(json)
  guard v is Ok(inputSchema) else {
    raise @json.JsonDecodeError((path, "expected field 'inputSchema'"))
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  { annotations, description, inputSchema, name }
}

////////////////////////////////////////////////////////////////////////////////
// Logging
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for SetLevelRequestParams with to_json(self) {
  let obj = {}
  obj["level"] = self.level.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SetLevelRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["level"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let v : Result[LoggingLevel, _] = @json.from_json?(json)
  guard v is Ok(level) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  { level, }
}

///|
pub impl ToJson for SetLevelRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SetLevelRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[SetLevelRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for LoggingMessageNotificationParams with to_json(self) {
  let obj = {}
  obj["data"] = self.data.to_json()
  obj["level"] = self.level.to_json()
  if self.logger is Some(v) {
    obj["logger"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for LoggingMessageNotificationParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["data"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[Json, _] = @json.from_json?(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj["level"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let v : Result[LoggingLevel, _] = @json.from_json?(json)
  guard v is Ok(level) else {
    raise @json.JsonDecodeError((path, "expected field 'level'"))
  }
  let logger : String? = match obj["logger"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { data, level, logger }
}

///|
pub impl ToJson for LoggingMessageNotification with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for LoggingMessageNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[LoggingMessageNotificationParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Sampling
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CreateMessageRequestParams with to_json(self) {
  let obj = {}
  if self.includeContext is Some(v) {
    obj["includeContext"] = v.to_json()
  }
  obj["maxTokens"] = self.maxTokens.to_json()
  obj["messages"] = self.messages.to_json()
  if self.metadata is Some(v) {
    obj["metadata"] = v.to_json()
  }
  if self.modelPreferences is Some(v) {
    obj["modelPreferences"] = v.to_json()
  }
  if self.stopSequences is Some(v) {
    obj["stopSequences"] = v.to_json()
  }
  if self.systemPrompt is Some(v) {
    obj["systemPrompt"] = v.to_json()
  }
  if self.temperature is Some(v) {
    obj["temperature"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageRequestParams with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let includeContext : IncludeContext? = match obj["includeContext"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["maxTokens"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'maxTokens'"))
  }
  let v : Result[Int64, _] = @json.from_json?(json)
  guard v is Ok(maxTokens) else {
    raise @json.JsonDecodeError((path, "expected field 'maxTokens'"))
  }
  guard obj["messages"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let v : Result[Array[SamplingMessage], _] = @json.from_json?(json)
  guard v is Ok(messages) else {
    raise @json.JsonDecodeError((path, "expected field 'messages'"))
  }
  let metadata : Map[String, Json]? = match obj["metadata"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let modelPreferences : ModelPreferences? = match obj["modelPreferences"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let stopSequences : Array[String]? = match obj["stopSequences"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let systemPrompt : String? = match obj["systemPrompt"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let temperature : Double? = match obj["temperature"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  {
    includeContext,
    maxTokens,
    messages,
    metadata,
    modelPreferences,
    stopSequences,
    systemPrompt,
    temperature,
  }
}

///|
pub impl ToJson for CreateMessageRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CreateMessageRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for CreateMessageResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["content"] = self.content.to_json()
  obj["model"] = self.model.to_json()
  obj["role"] = self.role.to_json()
  if self.stopReason is Some(v) {
    obj["stopReason"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for CreateMessageResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["content"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&CreateMessageResultContent, _] = @json.from_json?(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  guard obj["model"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'model'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(model) else {
    raise @json.JsonDecodeError((path, "expected field 'model'"))
  }
  guard obj["role"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = @json.from_json?(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let stopReason : String? = match obj["stopReason"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { _meta, content, model, role, stopReason }
}

///|
pub impl ToJson for SamplingMessage with to_json(self) {
  let obj = {}
  obj["content"] = self.content.to_json()
  obj["role"] = self.role.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for SamplingMessage with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["content"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  let v : Result[&SamplingMessageContent, _] = @json.from_json?(json)
  guard v is Ok(content) else {
    raise @json.JsonDecodeError((path, "expected field 'content'"))
  }
  guard obj["role"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  let v : Result[Role, _] = @json.from_json?(json)
  guard v is Ok(role) else {
    raise @json.JsonDecodeError((path, "expected field 'role'"))
  }
  { content, role }
}

///|
pub impl ToJson for Annotations with to_json(self) {
  let obj = {}
  if self.audience is Some(v) {
    obj["audience"] = v.to_json()
  }
  if self.priority is Some(v) {
    obj["priority"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for Annotations with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let audience : Array[Role]? = match obj["audience"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let priority : Double? = match obj["priority"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { audience, priority }
}

///|
pub impl ToJson for TextContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["text"] = self.text.to_json()
  obj["type"] = "text".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for TextContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["text"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(text) else {
    raise @json.JsonDecodeError((path, "expected field 'text'"))
  }
  guard obj["type"] == Some(String("text")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='text'"))
  }
  { annotations, text }
}

///|
pub impl ToJson for ImageContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  obj["type"] = "image".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ImageContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["data"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj["mimeType"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  guard obj["type"] == Some(String("image")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='image'"))
  }
  { annotations, data, mimeType }
}

///|
pub impl ToJson for AudioContent with to_json(self) {
  let obj = {}
  if self.annotations is Some(v) {
    obj["annotations"] = v.to_json()
  }
  obj["data"] = self.data.to_json()
  obj["mimeType"] = self.mimeType.to_json()
  obj["type"] = "audio".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for AudioContent with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let annotations : Annotations? = match obj["annotations"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["data"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(data) else {
    raise @json.JsonDecodeError((path, "expected field 'data'"))
  }
  guard obj["mimeType"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(mimeType) else {
    raise @json.JsonDecodeError((path, "expected field 'mimeType'"))
  }
  guard obj["type"] == Some(String("audio")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='audio'"))
  }
  { annotations, data, mimeType }
}

///|
pub impl ToJson for ModelPreferences with to_json(self) {
  let obj = {}
  if self.costPriority is Some(v) {
    obj["costPriority"] = v.to_json()
  }
  if self.hints is Some(v) {
    obj["hints"] = v.to_json()
  }
  if self.intelligencePriority is Some(v) {
    obj["intelligencePriority"] = v.to_json()
  }
  if self.speedPriority is Some(v) {
    obj["speedPriority"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ModelPreferences with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let costPriority : Double? = match obj["costPriority"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let hints : Array[ModelHint]? = match obj["hints"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let intelligencePriority : Double? = match obj["intelligencePriority"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let speedPriority : Double? = match obj["speedPriority"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { costPriority, hints, intelligencePriority, speedPriority }
}

///|
pub impl ToJson for ModelHint with to_json(self) {
  let obj = {}
  if self.name is Some(v) {
    obj["name"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ModelHint with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let name : String? = match obj["name"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { name, }
}

////////////////////////////////////////////////////////////////////////////////
// Autocomplete
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for CompleteRequestParamsArgument with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["value"] = self.value.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequestParamsArgument with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj["value"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'value'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(value) else {
    raise @json.JsonDecodeError((path, "expected field 'value'"))
  }
  { name, value }
}

///|
pub impl ToJson for CompleteRequestParams with to_json(self) {
  let obj = {}
  obj["argument"] = self.argument.to_json()
  obj["ref"] = self.ref_.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequestParams with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["argument"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  let v : Result[CompleteRequestParamsArgument, _] = @json.from_json?(json)
  guard v is Ok(argument) else {
    raise @json.JsonDecodeError((path, "expected field 'argument'"))
  }
  guard obj["ref"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  let v : Result[&CompleteRequestParamsRef, _] = @json.from_json?(json)
  guard v is Ok(ref_) else {
    raise @json.JsonDecodeError((path, "expected field 'ref'"))
  }
  { argument, ref_ }
}

///|
pub impl ToJson for CompleteRequest with to_json(self) {
  let obj = {}
  obj["params"] = self.params.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["params"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  let v : Result[CompleteRequestParams, _] = @json.from_json?(json)
  guard v is Ok(params) else {
    raise @json.JsonDecodeError((path, "expected field 'params'"))
  }
  { params, }
}

///|
pub impl ToJson for CompleteResultCompletion with to_json(self) {
  let obj = {}
  if self.hasMore is Some(v) {
    obj["hasMore"] = v.to_json()
  }
  if self.total is Some(v) {
    obj["total"] = v.to_double().to_json()
  }
  obj["values"] = self.values.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteResultCompletion with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let hasMore : Bool? = match obj["hasMore"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  let total : Int64? = match obj["total"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(Number(v)) => Some(v.to_int64())
        _ => raise @json.JsonDecodeError((path, "expected number; got \{v}"))
      }
    None => None
  }
  guard obj["values"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'values'"))
  }
  let v : Result[Array[String], _] = @json.from_json?(json)
  guard v is Ok(values) else {
    raise @json.JsonDecodeError((path, "expected field 'values'"))
  }
  { hasMore, total, values }
}

///|
pub impl ToJson for CompleteResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["completion"] = self.completion.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for CompleteResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["completion"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'completion'"))
  }
  let v : Result[CompleteResultCompletion, _] = @json.from_json?(json)
  guard v is Ok(completion) else {
    raise @json.JsonDecodeError((path, "expected field 'completion'"))
  }
  { _meta, completion }
}

///|
pub impl ToJson for ResourceReference with to_json(self) {
  let obj = {}
  obj["type"] = "ref/resource".to_json()
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ResourceReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["type"] == Some(String("ref/resource")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/resource'"))
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { uri, }
}

///|
pub impl ToJson for PromptReference with to_json(self) {
  let obj = {}
  obj["name"] = self.name.to_json()
  obj["type"] = "ref/prompt".to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for PromptReference with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  guard obj["name"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(name) else {
    raise @json.JsonDecodeError((path, "expected field 'name'"))
  }
  guard obj["type"] == Some(String("ref/prompt")) else {
    raise @json.JsonDecodeError((path, "expected 'type'='ref/prompt'"))
  }
  { name, }
}

////////////////////////////////////////////////////////////////////////////////
// Roots
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for ListRootsRequest with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for ListRootsRequest with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

///|
pub impl ToJson for ListRootsResult with to_json(self) {
  let obj = {}
  if self._meta is Some(v) {
    obj["_meta"] = v.to_json()
  }
  obj["roots"] = self.roots.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for ListRootsResult with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let _meta : Map[String, Json]? = match obj["_meta"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["roots"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'roots'"))
  }
  let v : Result[Array[Root], _] = @json.from_json?(json)
  guard v is Ok(roots) else {
    raise @json.JsonDecodeError((path, "expected field 'roots'"))
  }
  { _meta, roots }
}

///|
pub impl ToJson for Root with to_json(self) {
  let obj = {}
  if self.name is Some(v) {
    obj["name"] = v.to_json()
  }
  obj["uri"] = self.uri.to_json()
  obj.to_json()
}

///|
pub impl @json.FromJson for Root with from_json(json, path) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let name : String? = match obj["name"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  guard obj["uri"] is Some(json) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  let v : Result[String, _] = @json.from_json?(json)
  guard v is Ok(uri) else {
    raise @json.JsonDecodeError((path, "expected field 'uri'"))
  }
  { name, uri }
}

///|
pub impl ToJson for RootsListChangedNotification with to_json(self) {
  let obj = {}
  if self.params is Some(v) {
    obj["params"] = v.to_json()
  }
  obj.to_json()
}

///|
pub impl @json.FromJson for RootsListChangedNotification with from_json(
  json,
  path
) {
  guard json is Object(obj) else {
    raise @json.JsonDecodeError((path, "expected object"))
  }
  let params : Map[String, Json]? = match obj["params"] {
    Some(v) =>
      match @json.from_json?(v) {
        Ok(v) => Some(v)
        Err(e) => raise e
      }
    None => None
  }
  { params, }
}

////////////////////////////////////////////////////////////////////////////////
// Client messages
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Server messages
////////////////////////////////////////////////////////////////////////////////
