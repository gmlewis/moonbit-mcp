// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT
// Generated from: https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26

////////////////////////////////////////////////////////////////////////////////
// JSON-RPC types
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Empty result
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Cancellation
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Initialization
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Ping
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Progress notifications
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Pagination
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Resources
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ReadResourceResultContents for TextResourceContents with unused(_self) {

}

///|
pub impl ReadResourceResultContents for BlobResourceContents with unused(_self) {

}

///|
pub impl @json.FromJson for &ReadResourceResultContents with from_json(
  json,
  path
) {
  let v : Result[TextResourceContents, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[BlobResourceContents, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextResourceContents, BlobResourceContents; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Prompts
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for Role with to_json(self) {
  match self {
    Assistant => "assistant".to_json()
    User => "user".to_json()
  }
}

///|
pub impl @json.FromJson for Role with from_json(json, path) {
  guard json is String(s) else {
    raise @json.JsonDecodeError((path, "expected string"))
  }
  match s {
    "assistant" => Assistant
    "user" => User
    _ =>
      raise @json.JsonDecodeError(
        (path, "expected one of: 'assistant', 'user'; got '\{s}'"),
      )
  }
}

///|
pub impl PromptMessageContent for TextContent with unused(_self) {

}

///|
pub impl PromptMessageContent for ImageContent with unused(_self) {

}

///|
pub impl PromptMessageContent for AudioContent with unused(_self) {

}

///|
pub impl PromptMessageContent for EmbeddedResource with unused(_self) {

}

///|
pub impl @json.FromJson for &PromptMessageContent with from_json(json, path) {
  let v : Result[TextContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ImageContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[AudioContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[EmbeddedResource, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextContent, ImageContent, AudioContent, EmbeddedResource; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl EmbeddedResourceResource for TextResourceContents with unused(_self) {

}

///|
pub impl EmbeddedResourceResource for BlobResourceContents with unused(_self) {

}

///|
pub impl @json.FromJson for &EmbeddedResourceResource with from_json(json, path) {
  let v : Result[TextResourceContents, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[BlobResourceContents, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextResourceContents, BlobResourceContents; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Tools
////////////////////////////////////////////////////////////////////////////////

///|
pub impl CallToolResultContent for TextContent with unused(_self) {

}

///|
pub impl CallToolResultContent for ImageContent with unused(_self) {

}

///|
pub impl CallToolResultContent for AudioContent with unused(_self) {

}

///|
pub impl CallToolResultContent for EmbeddedResource with unused(_self) {

}

///|
pub impl @json.FromJson for &CallToolResultContent with from_json(json, path) {
  let v : Result[TextContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ImageContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[AudioContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[EmbeddedResource, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextContent, ImageContent, AudioContent, EmbeddedResource; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Logging
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for LoggingLevel with to_json(self) {
  match self {
    Alert => "alert".to_json()
    Critical => "critical".to_json()
    Debug => "debug".to_json()
    Emergency => "emergency".to_json()
    Error => "error".to_json()
    Info => "info".to_json()
    Notice => "notice".to_json()
    Warning => "warning".to_json()
  }
}

///|
pub impl @json.FromJson for LoggingLevel with from_json(json, path) {
  guard json is String(s) else {
    raise @json.JsonDecodeError((path, "expected string"))
  }
  match s {
    "alert" => Alert
    "critical" => Critical
    "debug" => Debug
    "emergency" => Emergency
    "error" => Error
    "info" => Info
    "notice" => Notice
    "warning" => Warning
    _ =>
      raise @json.JsonDecodeError(
        (
          path,
          "expected one of: 'alert', 'critical', 'debug', 'emergency', 'error', 'info', 'notice', 'warning'; got '\{s}'",
        ),
      )
  }
}

////////////////////////////////////////////////////////////////////////////////
// Sampling
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ToJson for IncludeContext with to_json(self) {
  match self {
    AllServers => "allServers".to_json()
    NoServers => "none".to_json()
    ThisServer => "thisServer".to_json()
  }
}

///|
pub impl @json.FromJson for IncludeContext with from_json(json, path) {
  guard json is String(s) else {
    raise @json.JsonDecodeError((path, "expected string"))
  }
  match s {
    "allServers" => AllServers
    "none" => NoServers
    "thisServer" => ThisServer
    _ =>
      raise @json.JsonDecodeError(
        (
          path,
          "expected one of: 'allServers', 'none', 'thisServer'; got '\{s}'",
        ),
      )
  }
}

///|
pub impl CreateMessageResultContent for TextContent with unused(_self) {

}

///|
pub impl CreateMessageResultContent for ImageContent with unused(_self) {

}

///|
pub impl CreateMessageResultContent for AudioContent with unused(_self) {

}

///|
pub impl @json.FromJson for &CreateMessageResultContent with from_json(
  json,
  path
) {
  let v : Result[TextContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ImageContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[AudioContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextContent, ImageContent, AudioContent; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl SamplingMessageContent for TextContent with unused(_self) {

}

///|
pub impl SamplingMessageContent for ImageContent with unused(_self) {

}

///|
pub impl SamplingMessageContent for AudioContent with unused(_self) {

}

///|
pub impl @json.FromJson for &SamplingMessageContent with from_json(json, path) {
  let v : Result[TextContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ImageContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[AudioContent, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: TextContent, ImageContent, AudioContent; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Autocomplete
////////////////////////////////////////////////////////////////////////////////

///|
pub impl CompleteRequestParamsRef for PromptReference with unused(_self) {

}

///|
pub impl CompleteRequestParamsRef for ResourceReference with unused(_self) {

}

///|
pub impl @json.FromJson for &CompleteRequestParamsRef with from_json(json, path) {
  let v : Result[PromptReference, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ResourceReference, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: PromptReference, ResourceReference; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Roots
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Client messages
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ClientRequest for InitializeRequest with unused(_self) {

}

///|
pub impl ClientRequest for PingRequest with unused(_self) {

}

///|
pub impl ClientRequest for ListResourcesRequest with unused(_self) {

}

///|
pub impl ClientRequest for ReadResourceRequest with unused(_self) {

}

///|
pub impl ClientRequest for SubscribeRequest with unused(_self) {

}

///|
pub impl ClientRequest for UnsubscribeRequest with unused(_self) {

}

///|
pub impl ClientRequest for ListPromptsRequest with unused(_self) {

}

///|
pub impl ClientRequest for GetPromptRequest with unused(_self) {

}

///|
pub impl ClientRequest for ListToolsRequest with unused(_self) {

}

///|
pub impl ClientRequest for CallToolRequest with unused(_self) {

}

///|
pub impl ClientRequest for SetLevelRequest with unused(_self) {

}

///|
pub impl ClientRequest for CompleteRequest with unused(_self) {

}

///|
pub impl @json.FromJson for &ClientRequest with from_json(json, path) {
  let v : Result[InitializeRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[PingRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListResourcesRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ReadResourceRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[SubscribeRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[UnsubscribeRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListPromptsRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[GetPromptRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListToolsRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CallToolRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[SetLevelRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CompleteRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: InitializeRequest, PingRequest, ListResourcesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, ListPromptsRequest, GetPromptRequest, ListToolsRequest, CallToolRequest, SetLevelRequest, CompleteRequest; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl ClientNotification for CancelledNotification with unused(_self) {

}

///|
pub impl ClientNotification for InitializedNotification with unused(_self) {

}

///|
pub impl ClientNotification for ProgressNotification with unused(_self) {

}

///|
pub impl ClientNotification for RootsListChangedNotification with unused(_self) {

}

///|
pub impl @json.FromJson for &ClientNotification with from_json(json, path) {
  let v : Result[CancelledNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[InitializedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ProgressNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[RootsListChangedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: CancelledNotification, InitializedNotification, ProgressNotification, RootsListChangedNotification; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl ClientResult for EmptyResult with unused(_self) {

}

///|
pub impl ClientResult for CreateMessageResult with unused(_self) {

}

///|
pub impl ClientResult for ListRootsResult with unused(_self) {

}

///|
pub impl @json.FromJson for &ClientResult with from_json(json, path) {
  let v : Result[EmptyResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CreateMessageResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListRootsResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: EmptyResult, CreateMessageResult, ListRootsResult; got: \{@json.stringify(json)}",
    ),
  )
}

////////////////////////////////////////////////////////////////////////////////
// Server messages
////////////////////////////////////////////////////////////////////////////////

///|
pub impl ServerRequest for PingRequest with unused(_self) {

}

///|
pub impl ServerRequest for CreateMessageRequest with unused(_self) {

}

///|
pub impl ServerRequest for ListRootsRequest with unused(_self) {

}

///|
pub impl @json.FromJson for &ServerRequest with from_json(json, path) {
  let v : Result[PingRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CreateMessageRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListRootsRequest, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: PingRequest, CreateMessageRequest, ListRootsRequest; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl ServerNotification for CancelledNotification with unused(_self) {

}

///|
pub impl ServerNotification for ProgressNotification with unused(_self) {

}

///|
pub impl ServerNotification for ResourceListChangedNotification with unused(
  _self
) {

}

///|
pub impl ServerNotification for ResourceUpdatedNotification with unused(_self) {

}

///|
pub impl ServerNotification for PromptListChangedNotification with unused(_self) {

}

///|
pub impl ServerNotification for ToolListChangedNotification with unused(_self) {

}

///|
pub impl ServerNotification for LoggingMessageNotification with unused(_self) {

}

///|
pub impl @json.FromJson for &ServerNotification with from_json(json, path) {
  let v : Result[CancelledNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ProgressNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ResourceListChangedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ResourceUpdatedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[PromptListChangedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ToolListChangedNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[LoggingMessageNotification, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: CancelledNotification, ProgressNotification, ResourceListChangedNotification, ResourceUpdatedNotification, PromptListChangedNotification, ToolListChangedNotification, LoggingMessageNotification; got: \{@json.stringify(json)}",
    ),
  )
}

///|
pub impl ServerResult for EmptyResult with unused(_self) {

}

///|
pub impl ServerResult for InitializeResult with unused(_self) {

}

///|
pub impl ServerResult for ListResourcesResult with unused(_self) {

}

///|
pub impl ServerResult for ReadResourceResult with unused(_self) {

}

///|
pub impl ServerResult for ListPromptsResult with unused(_self) {

}

///|
pub impl ServerResult for GetPromptResult with unused(_self) {

}

///|
pub impl ServerResult for ListToolsResult with unused(_self) {

}

///|
pub impl ServerResult for CallToolResult with unused(_self) {

}

///|
pub impl ServerResult for CompleteResult with unused(_self) {

}

///|
pub impl @json.FromJson for &ServerResult with from_json(json, path) {
  let v : Result[EmptyResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[InitializeResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListResourcesResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ReadResourceResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListPromptsResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[GetPromptResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[ListToolsResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CallToolResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  let v : Result[CompleteResult, _] = @json.from_json?(json)
  if v is Ok(v) {
    return v
  }
  raise @json.JsonDecodeError(
    (
      path,
      "expected one of: EmptyResult, InitializeResult, ListResourcesResult, ReadResourceResult, ListPromptsResult, GetPromptResult, ListToolsResult, CallToolResult, CompleteResult; got: \{@json.stringify(json)}",
    ),
  )
}
