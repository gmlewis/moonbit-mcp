// -*- compile-command: "go run ."; -*-

// schema-to-types reads the official MCP schema.json file and generates
// corresponding MoonBit types.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
)

var (
	baseDir   = flag.String("dir", "../..", "Base directory to write auto-generated files into")
	schemaURL = flag.String("schema", "https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26", "Browser GitHub URL to latest MCP schema dir")
)

const (
	autoGenHeader = "// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT\n"
	githubPrefix  = "https://github.com/"
	rawPrefix     = "https://raw.githubusercontent.com/"
)

func main() {
	log.SetFlags(0)
	flag.Parse()

	url := *schemaURL
	if url == "" {
		log.Fatal("Must supply -schema")
	}
	if strings.HasPrefix(url, githubPrefix) {
		url = rawPrefix + strings.Replace(url[len(githubPrefix):], "/blob/", "/refs/heads/", 1)
	}

	jsonSchema := goGet(url + "/schema.json")
	tsSchema := goGet(url + "/schema.ts")
	defs, categories := chunkify(string(tsSchema))

	var schema *Schema
	must(json.Unmarshal(jsonSchema, &schema))
	schema.tsDefs = defs

	// urlParts := strings.Split(*schemaURL, "/")
	// mcpVersion := urlParts[len(urlParts)-1]
	commentRow := strings.Repeat("/", 80)

	out := &outBufsT{}
	firstCategory, ok := categories.Get("")
	if !ok {
		log.Fatal("Unable to find first category")
	}
	fileHeader := autoGenHeader + fmt.Sprintf(`// Generated from: %v

%v
// %v
%[2]v
`, *schemaURL, commentRow, firstCategory)
	out.typesFile.WriteString(fileHeader)
	// out.typesFile.WriteString(fmt.Sprintf("\n///|\npub const MCP_VERSION = %q\n", mcpVersion))
	out.typesJSONEnumsFile.WriteString(fileHeader)
	out.typesJSONFile.WriteString(fileHeader)
	out.typesNewFile.WriteString(fileHeader)

	// Generate MoonBit source from the schema
	for pair := defs.Oldest(); pair != nil; pair = pair.Next() {
		key := pair.Key
		def, ok := schema.Definitions[key]
		if !ok {
			if key == "JSONRPC_VERSION" {
				continue
			}
			if !strings.HasPrefix(pair.Value, "export const ") {
				log.Fatalf("missing schema.Definitions[%q]: %v", key, pair.Value)
			}
			out.typesFile.WriteString("\n///|\npub " + pair.Value[7:len(pair.Value)-1] + "\n")
			continue
		}

		if category, ok := categories.Get(key); ok {
			category = fmt.Sprintf("\n%v\n// %v\n%[1]v\n", commentRow, category)
			out.typesFile.WriteString(category)
			out.typesJSONEnumsFile.WriteString(category)
			out.typesJSONFile.WriteString(category)
			out.typesNewFile.WriteString(category)
		}

		mbt := schema.convert(def, out, key)
		if mbt == "" {
			continue
		}
		out.typesFile.WriteString("\n" + mbt + "\n")
		for _, helper := range def.helperStructsAndMethods {
			out.typesFile.WriteString("\n" + helper + "\n")
		}
	}

	out.writeBuffersToFiles(*baseDir)

	log.Printf("Done.")
}

func goGet(url string) []byte {
	resp, err := http.Get(url)
	must(err)
	defer resp.Body.Close()
	buf, err := io.ReadAll(resp.Body)
	must(err)
	return buf
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
