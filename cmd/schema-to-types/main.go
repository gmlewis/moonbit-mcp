// -*- compile-command: "go run ."; -*-

// schema-to-types reads the official MCP schema.json file and generates
// corresponding MoonBit types.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"sort"
	"strings"
)

var (
	baseDir   = flag.String("dir", "../..", "Base directory to write auto-generated files into")
	schemaURL = flag.String("schema", "https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.json", "Browser GitHub URL to latest MCP schema")
)

const (
	autoGenHeader = "// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT\n"
	githubPrefix  = "https://github.com/"
	rawPrefix     = "https://raw.githubusercontent.com/"
)

func main() {
	log.SetFlags(0)
	flag.Parse()

	url := *schemaURL
	if url == "" {
		log.Fatal("Must supply -schema")
	}
	if strings.HasPrefix(url, githubPrefix) {
		url = rawPrefix + strings.Replace(url[len(githubPrefix):], "/blob/", "/refs/heads/", 1)
	}

	resp, err := http.Get(url)
	must(err)
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	must(err)

	var schema *Schema
	must(json.Unmarshal(body, &schema))

	keys := make([]string, 0, len(schema.Definitions))
	for key := range schema.Definitions {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	urlParts := strings.Split(strings.TrimSuffix(*schemaURL, "/schema.json"), "/")
	mcpVersion := urlParts[len(urlParts)-1]

	out := &outBufsT{}
	fileHeader := autoGenHeader + fmt.Sprintf("// Generated from: %v\n", *schemaURL)
	out.typesFile.WriteString(fileHeader)
	out.typesFile.WriteString(fmt.Sprintf("\n///|\npub const MCP_VERSION = %q\n", mcpVersion))
	out.typesJSONEnumsFile.WriteString(fileHeader)
	out.typesJSONFile.WriteString(fileHeader)
	out.typesNewFile.WriteString(fileHeader)

	// Generate MoonBit source from the schema
	for _, key := range keys {
		def := schema.Definitions[key]
		mbt := def.convert(out, key)
		if mbt == "" {
			continue
		}
		out.typesFile.WriteString("\n" + mbt + "\n")
		for _, helper := range def.helperStructsAndMethods {
			out.typesFile.WriteString("\n" + helper + "\n")
		}
	}

	out.writeBuffersToFiles(*baseDir)

	log.Printf("Done.")
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
