// -*- compile-command: "go run ."; -*-

// schema-to-types reads the official MCP schema.json file and generates
// corresponding MoonBit types.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"slices"
	"sort"
	"strings"
)

var (
	baseDir   = flag.String("dir", "../..", "Base directory to write auto-generated files into")
	schemaURL = flag.String("schema", "https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-03-26/schema.json", "Browser GitHub URL to latest MCP schema")
)

const (
	autoGenHeader = "// AUTO-GENERATED BY cmd/schema-to-types - DO NOT EDIT\n"
	githubPrefix  = "https://github.com/"
	rawPrefix     = "https://raw.githubusercontent.com/"
)

func main() {
	log.SetFlags(0)
	flag.Parse()

	url := *schemaURL
	if url == "" {
		log.Fatal("Must supply -schema")
	}
	if strings.HasPrefix(url, githubPrefix) {
		url = rawPrefix + strings.Replace(url[len(githubPrefix):], "/blob/", "/refs/heads/", 1)
	}

	resp, err := http.Get(url)
	must(err)
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	must(err)

	var schema *Schema
	must(json.Unmarshal(body, &schema))

	keys := make([]string, 0, len(schema.Definitions))
	for key := range schema.Definitions {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	urlParts := strings.Split(strings.TrimSuffix(*schemaURL, "/schema.json"), "/")
	mcpVersion := urlParts[len(urlParts)-1]

	out := &outBufsT{}
	fileHeader := autoGenHeader + fmt.Sprintf("// Generated from: %v\n", *schemaURL)
	out.typesFile.WriteString(fileHeader)
	out.typesFile.WriteString(fmt.Sprintf("\n///|\npub const MCP_VERSION = %q\n", mcpVersion))
	out.typesJSONEnumsFile.WriteString(fileHeader)
	out.typesJSONFile.WriteString(fileHeader)
	out.typesNewFile.WriteString(fileHeader)

	// Generate MoonBit source from the schema
	for _, key := range keys {
		def := schema.Definitions[key]
		mbt := def.convert(out, key)
		if mbt == "" {
			continue
		}
		out.typesFile.WriteString("\n" + mbt + "\n")
		for _, helper := range def.helperStructsAndMethods {
			out.typesFile.WriteString("\n" + helper + "\n")
		}
	}

	out.writeBuffersToFiles(*baseDir)

	log.Printf("Done.")
}

type skipType int

const (
	skipButComment = iota
	totallyIgnore
)

var structsToSkip = map[string]skipType{
	"EmptyResult":          totallyIgnore,
	"JSONRPCBatchRequest":  totallyIgnore,
	"JSONRPCBatchResponse": totallyIgnore,
	"JSONRPCError":         totallyIgnore,
	"JSONRPCMessage":       totallyIgnore,
	"JSONRPCNotification":  totallyIgnore,
	"JSONRPCRequest":       totallyIgnore,
	"JSONRPCResponse":      totallyIgnore,
	"@jsonrpc2.ID":         totallyIgnore, // `ResultId` converted to `@jsonrpc2.ID`
}

func (d *Definition) convert(out *outBufsT, name string) string {
	name = safeStructName(name)
	d.name = name
	var prefix string
	if v, ok := structsToSkip[name]; ok {
		if v == totallyIgnore {
			return ""
		}
		prefix = "// "
	}

	if len(d.Properties) == 0 && len(d.AnyOf) > 0 {
		return d.convertEnumAnyOf(out, name, prefix)
	}
	if len(d.Enum) > 0 {
		return d.convertEnumStrings(out, name, prefix)
	}

	lines := []string{prefix + "///|"}
	if d.Description != "" {
		desc := strings.Replace(d.Description, "\n", "\n"+prefix+"/// ", -1)
		// clean up trailing whitespace within description:
		desc = strings.Replace(desc, " \n", "\n", -1)
		lines = append(lines, fmt.Sprintf(prefix+"/// %v: %v", name, desc))
	}
	lines = append(lines, fmt.Sprintf(prefix+"pub(all) struct %v {", name))

	newLines := []string{
		prefix + "///|",
		fmt.Sprintf("pub fn %v::new(", name),
	}

	selfVar := "self"
	if len(d.Properties) == 0 {
		selfVar = "_self"
	}
	toJSONLines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl ToJson for %v with to_json(%v) {", name, selfVar),
		prefix + "  let obj = {}",
	}

	var fromJSONLastLineFields []string
	objVar := "obj"
	if len(d.Properties) == 0 {
		objVar = "_obj"
	}
	fromJSONLines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl @json.FromJson for %v with from_json(json, path) {", name),
		fmt.Sprintf(prefix+"  guard json is Object(%v) else {", objVar),
		prefix + `    raise @json.JsonDecodeError((path, "expected object"))`,
		prefix + "  }",
	}

	props := make([]string, 0, len(d.Properties))
	for key := range d.Properties {
		props = append(props, key)
	}
	sort.Strings(props)

	jsonRPCConsts := map[string]string{}
	for _, propName := range props {
		prop := d.Properties[propName]
		if prop.Description != "" {
			desc := strings.Replace(prop.Description, "\n", "\n"+prefix+"  /// ", -1)
			// clean up trailing whitespace within description:
			desc = strings.Replace(desc, " \n", "\n", -1)
			comment := fmt.Sprintf(prefix+"  /// %v", desc)
			lines = append(lines, comment)
			newLines = append(newLines, comment)
		}
		if len(prop.Const) > 0 {
			value, err := json.Marshal(prop.Const)
			must(err)
			jsonRPCConsts[propName] = string(value)
			if propName != "method" {
				toJSONLines = append(toJSONLines, fmt.Sprintf(prefix+"  obj[%q] = %s.to_json()", propName, value))
				fromJSONLines = append(fromJSONLines,
					fmt.Sprintf(prefix+"  guard obj[%q] == Some(String(%s)) else {", propName, value),
					fmt.Sprintf(prefix+`    raise @json.JsonDecodeError((path, "expected '%v'='%v'"))`, propName, strings.ReplaceAll(string(value), `"`, "")),
					prefix+"  }")
			}
			lines = append(lines, fmt.Sprintf(prefix+`  /// JSON-RPC: %q = %s`, propName, value))
			continue
		}
		safeName := safePropName(propName)
		mbtType := d.moonBitType(out, propName, prop)
		lines = append(lines, fmt.Sprintf(prefix+"  %v : %v", safeName, mbtType))
		fromJSONLastLineFields = append(fromJSONLastLineFields, safeName)

		if strings.HasSuffix(mbtType, "?") {
			var injectToDouble string
			if mbtType == "Int64?" {
				injectToDouble = ".to_double()"
			}
			toJSONLines = append(toJSONLines,
				fmt.Sprintf(prefix+"  if self.%v is Some(v) {", propName),
				fmt.Sprintf(prefix+"    obj[%q] = v%v.to_json()", propName, injectToDouble),
				"  }")
			fromJSONLines = append(fromJSONLines,
				fmt.Sprintf(prefix+"  let %v : %v = match obj[%[1]q] {", propName, mbtType),
				prefix+"    Some(v) =>",
				prefix+"      match @json.from_json?(v) {")
			if mbtType == "Int64?" {
				fromJSONLines = append(fromJSONLines,
					prefix+`Ok(Number(v)) => Some(v.to_int64())`,
					prefix+`_ => raise @json.JsonDecodeError((path, "expected number; got \{v}"))`)
			} else {
				fromJSONLines = append(fromJSONLines,
					prefix+"        Ok(v) => Some(v)",
					prefix+"        Err(e) => raise e")
			}
			fromJSONLines = append(fromJSONLines,
				prefix+"      }",
				prefix+"    None => None",
				prefix+"  }")
			newLines = append(newLines, fmt.Sprintf(prefix+"  %v? : %v,", safeName, strings.TrimSuffix(mbtType, "?")))
		} else {
			toJSONLines = append(toJSONLines, fmt.Sprintf(prefix+"  obj[%q] = self.%v.to_json()", propName, safeName))
			fromJSONLines = append(fromJSONLines,
				fmt.Sprintf(prefix+"  guard obj[%q] is Some(json) else {", propName),
				fmt.Sprintf(prefix+`    raise @json.JsonDecodeError((path, "expected field '%v'"))`, propName),
				prefix+"  }",
				fmt.Sprintf(prefix+"  let v : Result[%v, _] = @json.from_json?(json)", mbtType),
				fmt.Sprintf(prefix+"  guard v is Ok(%v) else {", safeName),
				fmt.Sprintf(prefix+`    raise @json.JsonDecodeError((path, "expected field '%v'"))`, propName),
				prefix+"  }",
			)
			newLines = append(newLines, fmt.Sprintf(prefix+"  %v : %v,", safeName, mbtType))
		}
	}

	toJSONLines = append(toJSONLines, prefix+"  obj.to_json()", "}")
	fromJSONLines = append(fromJSONLines,
		fmt.Sprintf(prefix+"  %v::{ ", name)+strings.Join(fromJSONLastLineFields, ", ")+" }",
		prefix+"}")
	lines = append(lines,
		prefix+"} derive(Show, Eq)")
	out.typesJSONFile.WriteString("\n" + strings.Join(toJSONLines, "\n") + "\n")
	out.typesJSONFile.WriteString("\n" + strings.Join(fromJSONLines, "\n") + "\n")

	newLines = append(newLines,
		fmt.Sprintf(prefix+") -> %v {", name),
		fmt.Sprintf(prefix+"  %v::{ ", name)+strings.Join(fromJSONLastLineFields, ", ")+" }",
		prefix+"}")
	out.typesNewFile.WriteString("\n" + strings.Join(newLines, "\n") + "\n")

	// generate any helper methods
	d.genHelperMethods(jsonRPCConsts)

	return strings.Join(lines, "\n")
}

func (d *Definition) convertEnumAnyOf(out *outBufsT, name, prefix string) string {
	if len(d.AnyOf) == 0 || len(d.Enum) > 0 {
		log.Fatalf("PROGRAMMING ERROR: convertEnumAnyOf: d.AnyOf=nil, d.Enum=%+v", d.Enum)
	}

	lines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub trait %v: Show + ToJson {", name),
		prefix + "  unused(Self) -> Unit",
		prefix + "}",
		"",
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl Eq for &%v with op_equal(_self, _other) {", name),
		prefix + "  false // unused",
		prefix + "}",
	}

	// toJSONLines := []string{
	// prefix + "///|",
	// fmt.Sprintf(prefix+"pub impl ToJson for %v with to_json(self) {", name),
	// prefix + "  match self {",
	// }

	var fromJSONOptions []string
	fromJSONLines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl @json.FromJson for &%v with from_json(json, path) {", name),
	}

	// if len(d.Enum) > 0 {
	// 	fromJSONOptions = make([]string, 0, len(d.Enum))
	// 	fromJSONLines = append(fromJSONLines,
	// 		prefix+"  guard json is String(s) else {",
	// 		prefix+`    raise @json.JsonDecodeError((path, "expected string"))`,
	// 		prefix+"  }",
	// 		prefix+"  match s {",
	// 	)
	// } else {
	//
	// }

	for _, def := range d.AnyOf {
		refType, _ := def.refType(name, nil)
		refType = strings.TrimSuffix(refType, "?")
		// lines = append(lines, fmt.Sprintf(prefix+"  %v(%[1]v)", refType))
		// toJSONLines = append(toJSONLines,
		// 	fmt.Sprintf(prefix+"    %v(v) => v.to_json(),", refType),
		// )
		implLines := []string{
			prefix + "///|",
			fmt.Sprintf(prefix+"pub impl %v for %v with unused(_self) {", name, refType),
			prefix,
			prefix + "}",
		}
		out.typesJSONEnumsFile.WriteString("\n" + strings.Join(implLines, "\n") + "\n")
		fromJSONOptions = append(fromJSONOptions, refType)
		fromJSONLines = append(fromJSONLines,
			fmt.Sprintf(prefix+"  let v : Result[%v, _] = @json.from_json?(json)", refType),
			prefix+"  if v is Ok(v) {",
			prefix+"    return v",
			prefix+"  }",
		)
	}

	// lines = append(lines, prefix+"} derive(Show, Eq)")

	// toJSONLines = append(toJSONLines, prefix+"  }")
	// toJSONLines = append(toJSONLines, prefix+"}")
	// out.typesJSONEnumsFile.WriteString("\n" + strings.Join(toJSONLines, "\n") + "\n")

	// if len(d.Enum) > 0 {
	// 	fromJSONLines = append(fromJSONLines,
	// 		prefix+"  _ =>",
	// 		prefix+"  raise @json.JsonDecodeError(",
	// 		fmt.Sprintf(prefix+`    (path, "expected one of: '%v'; got '\{s}'"),`, strings.Join(fromJSONOptions, "', '")),
	// 		prefix+"  )",
	// 		prefix+"}")
	// } else {
	fromJSONLines = append(fromJSONLines,
		prefix+"  raise @json.JsonDecodeError(",
		fmt.Sprintf(prefix+`    (path, "expected one of: %v; got: \{@json.stringify(json)}"),`, strings.Join(fromJSONOptions, ", ")),
		prefix+"  )")
	// }
	fromJSONLines = append(fromJSONLines, prefix+"}")
	out.typesJSONEnumsFile.WriteString("\n" + strings.Join(fromJSONLines, "\n") + "\n")

	return strings.Join(lines, "\n")
}

func (d *Definition) convertEnumStrings(out *outBufsT, name, prefix string) string {
	if len(d.Enum) == 0 || len(d.AnyOf) > 0 {
		log.Fatalf("PROGRAMMING ERROR: convertEnumStrings: d.Enum=nil, d.AnyOf=%+v", d.AnyOf)
	}

	lines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub(all) enum %v {", name),
	}

	toJSONLines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl ToJson for %v with to_json(self) {", name),
		prefix + "  match self {",
	}

	var fromJSONOptions []string
	fromJSONLines := []string{
		prefix + "///|",
		fmt.Sprintf(prefix+"pub impl @json.FromJson for %v with from_json(json, path) {", name),
	}

	// if len(d.Enum) > 0 {
	fromJSONOptions = make([]string, 0, len(d.Enum))
	fromJSONLines = append(fromJSONLines,
		prefix+"  guard json is String(s) else {",
		prefix+`    raise @json.JsonDecodeError((path, "expected string"))`,
		prefix+"  }",
		prefix+"  match s {",
	)
	// } else {
	//
	// }

	for _, rawEnum := range d.Enum {
		enumBuf, err := json.Marshal(rawEnum)
		must(err)
		noQuotesValue := strings.ReplaceAll(string(enumBuf), `"`, "")
		// lines = append(lines, fmt.Sprintf(prefix+"  %v_%v // = %v", name, titleCase(noQuotesValue), string(enumBuf)))
		enumName := titleCase(noQuotesValue)
		// special case: change "None" to "NoServers" for `IncludeContext`:
		if enumName == "None" {
			enumName = "NoServers"
		}
		lines = append(lines, fmt.Sprintf(prefix+"  %v // = %v", enumName, string(enumBuf)))
		toJSONLines = append(toJSONLines, fmt.Sprintf(prefix+"    %v => %s.to_json(),", enumName, string(enumBuf)))
		fromJSONOptions = append(fromJSONOptions, noQuotesValue)
		fromJSONLines = append(fromJSONLines, fmt.Sprintf(prefix+"    %q => %v", noQuotesValue, enumName))
	}

	lines = append(lines, prefix+"} derive(Show, Eq)")

	toJSONLines = append(toJSONLines, prefix+"  }")
	toJSONLines = append(toJSONLines, prefix+"}")
	out.typesJSONEnumsFile.WriteString("\n" + strings.Join(toJSONLines, "\n") + "\n")

	// if len(d.Enum) > 0 {
	fromJSONLines = append(fromJSONLines,
		prefix+"  _ =>",
		prefix+"  raise @json.JsonDecodeError(",
		fmt.Sprintf(prefix+`    (path, "expected one of: '%v'; got '\{s}'"),`, strings.Join(fromJSONOptions, "', '")),
		prefix+"  )",
		prefix+"}")
	// } else {
	// 	fromJSONLines = append(fromJSONLines,
	// 		prefix+"  raise @json.JsonDecodeError(",
	// 		fmt.Sprintf(prefix+`    (path, "expected one of: %v; got: \{@json.stringify(json)}"),`, strings.Join(fromJSONOptions, ", ")),
	// 		prefix+"  )")
	// }
	fromJSONLines = append(fromJSONLines, prefix+"}")
	out.typesJSONEnumsFile.WriteString("\n" + strings.Join(fromJSONLines, "\n") + "\n")

	return strings.Join(lines, "\n")
}

var reservedKeywords = map[string]string{
	"method": "method_",
	"ref":    "ref_",
	"type":   "type_",
}

func safeStructName(s string) string {
	switch s {
	case "Result":
		return "CustomResult"
	case "RequestId":
		// Here we are renaming a RequestId to the @jsonrpc.ID type.
		return "@jsonrpc2.ID"
	default:
		return s
	}
}

func safePropName(s string) string {
	if v, ok := reservedKeywords[s]; ok {
		return v
	}
	return s
}

func (d *Definition) moonBitType(out *outBufsT, propName string, prop *Definition) string {
	var suffix string
	if slices.Contains(d.Required, propName) {
		d.isRequired = true
	} else {
		suffix = "?"
	}

	typ := prop.Type
	v, err := json.Marshal(typ)
	must(err)
	switch string(v) {
	case `"boolean"`:
		return "Bool" + suffix
	case `"number"`:
		return "Double" + suffix
	case `"integer"`:
		return "Int64" + suffix
	case `"array"`:
		if len(prop.Items.AnyOf) > 0 {
			arrayType, anyOf := prop.Items.refType(propName, nil)
			if len(anyOf) > 0 {
				enumName := d.name + titleCase(propName)
				enumBody := prop.Items.convertEnumAnyOf(out, enumName, "")
				d.helperStructsAndMethods = append(d.helperStructsAndMethods, enumBody)
				return fmt.Sprintf("Array[&%v]", enumName)
			}
			return fmt.Sprintf("Array[%v]", arrayType)
		}
		arrayType := strings.TrimSuffix(prop.moonBitType(out, propName, prop.Items), "?")
		return fmt.Sprintf("Array[%v]", arrayType) + suffix
	case `"string"`:
		if len(prop.Enum) > 0 {
			enumName := titleCase(propName)
			enumBody := prop.convertEnumStrings(out, enumName, "")
			d.helperStructsAndMethods = append(d.helperStructsAndMethods, enumBody)
			return enumName + suffix
		}
		return "String" + suffix
	case `"object"`:
		if len(prop.Properties) == 0 {
			return "Json" + suffix
		}
		subTypeName := d.name + titleCase(propName)
		subType := prop.convert(out, subTypeName)
		d.helperStructsAndMethods = append(d.helperStructsAndMethods, subType)
		d.helperStructsAndMethods = append(d.helperStructsAndMethods, prop.helperStructsAndMethods...)
		return subTypeName + suffix
	case "null":
		refType, anyOf := prop.refType(propName, d.Required)
		if len(anyOf) > 0 {
			enumName := d.name + titleCase(propName)
			enumBody := prop.convertEnumAnyOf(out, enumName, "")
			d.helperStructsAndMethods = append(d.helperStructsAndMethods, enumBody)
			return "&" + enumName
		}
		return refType
	default:
		log.Fatalf("unhandled mooonBitType: %v", string(v))
	}
	return ""
}

func (d *Definition) refType(propName string, required []string) (refType string, anyOf []string) {
	if d != nil && len(d.AnyOf) > 0 {
		for _, def := range d.AnyOf {
			typ, _ := def.refType(propName, nil)
			anyOf = append(anyOf, typ)
		}
	} else if d == nil || d.Ref == "" {
		// special exception: "data" => Json
		if propName == "data" {
			return "Json", nil
		}
		log.Fatalf("nil definition or missing refType for propName %q", propName)
	}
	parts := strings.Split(d.Ref, "/")
	typeName := safeStructName(parts[len(parts)-1])
	if slices.Contains(required, propName) {
		d.isRequired = true
		return typeName, anyOf
	}
	// optional - not required
	return typeName + "?", anyOf
}

func (d *Definition) genHelperMethods(jsonRPCConsts map[string]string) {
	switch {
	case strings.HasSuffix(d.name, "Request"):
		d.genRequestHelperMethods(jsonRPCConsts)
	case strings.HasSuffix(d.name, "Notification"):
		d.genNotificationHelperMethods(jsonRPCConsts)
	case strings.HasSuffix(d.name, "Result"):
		d.genResultHelperMethods()
	}
}

func (d *Definition) genRequestHelperMethods(jsonRPCConsts map[string]string) {
	method, hasConstMethod := jsonRPCConsts["method"]
	if !hasConstMethod {
		method = "self.method_"
	}

	lines := []string{
		"///|",
		fmt.Sprintf("pub impl MCPRequest for %v with to_call(self, id) {", d.name),
		fmt.Sprintf("  @jsonrpc2.new_call(id, %v, self.params.to_json())", method),
		"}",
		"",
		"///|",
		fmt.Sprintf("pub fn %v::from_message(msg : @jsonrpc2.Message) -> (@jsonrpc2.ID, %[1]v)?  {", d.name),
		"  guard msg is Request(req) else { return None }",
		"  guard req.id is Some(id) else { return None }",
	}

	if hasConstMethod {
		lines = append(lines,
			fmt.Sprintf("  guard req.method_ == %v else { return None }", method),
			`  let json = { "params" : req.params }.to_json()`,
		)
	} else {
		lines = append(lines, `  let json = { "method_": req.method_.to_json(), "params": req.params }.to_json()`)
	}

	lines = append(lines,
		fmt.Sprintf("  let v : Result[%v, _] = @json.from_json?(json)", d.name),
		"  guard v is Ok(request) else { return None }",
		"  Some((id, request))",
		"}",
	)

	d.helperStructsAndMethods = append(d.helperStructsAndMethods, strings.Join(lines, "\n"))
}

func (d *Definition) genNotificationHelperMethods(jsonRPCConsts map[string]string) {
	method, hasConstMethod := jsonRPCConsts["method"]
	if !hasConstMethod {
		method = "self.method_"
	}

	lines := []string{
		"///|",
		fmt.Sprintf("pub impl MCPNotification for %v with to_notification(self) {", d.name),
		fmt.Sprintf("  @jsonrpc2.new_notification(%v, self.params.to_json())", method),
		"}",
		"",
		"///|",
		fmt.Sprintf("pub fn %v::from_message(msg : @jsonrpc2.Message) -> %[1]v?  {", d.name),
		"  guard msg is Request(req) else { return None }",
		"  guard req.id is None else { return None }",
	}

	if hasConstMethod {
		lines = append(lines,
			fmt.Sprintf("  guard req.method_ == %v else { return None }", method),
			`  let json = { "params" : req.params }.to_json()`,
		)
	} else {
		lines = append(lines, `  let json = { "method_": req.method_.to_json(), "params": req.params }.to_json()`)
	}

	lines = append(lines,
		fmt.Sprintf("  let v : Result[%v, _] = @json.from_json?(json)", d.name),
		"  guard v is Ok(notification) else { return None }",
		"  Some(notification)",
		"}",
	)

	d.helperStructsAndMethods = append(d.helperStructsAndMethods, strings.Join(lines, "\n"))
}

func (d *Definition) genResultHelperMethods() {
	lines := []string{
		"///|",
		fmt.Sprintf("pub impl MCPResponse for %v with to_response(self, id) {", d.name),
		"  @jsonrpc2.new_response(id, Ok(self.to_json()))",
		"}",
		"",
		"///|",
		fmt.Sprintf("pub fn %v::from_message(msg : @jsonrpc2.Message) -> (@jsonrpc2.ID, %[1]v)?  {", d.name),
		"  guard msg is Response(res) else { return None }",
		"  guard res.result is Ok(json) else { return None }",
		fmt.Sprintf("  let v : Result[%v, _] = @json.from_json?(json)", d.name),
		"  guard v is Ok(result) else { return None }",
		"  Some((res.id, result))",
		"}",
	}

	d.helperStructsAndMethods = append(d.helperStructsAndMethods, strings.Join(lines, "\n"))
}

func titleCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[0:1]) + s[1:]
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type Schema struct {
	Schema      string                 `json:"$schema"`
	Definitions map[string]*Definition `json:"definitions"`
}

type Definition struct {
	AdditionalProperties     any                    `json:"additionalProperties,omitempty"`
	AnyOf                    []*Definition          `json:"anyOf,omitempty"`
	Ref                      string                 `json:"$ref,omitempty"`
	Description              string                 `json:"description,omitempty"`
	Format                   string                 `json:"format,omitempty"`
	Properties               map[string]*Definition `json:"properties,omitempty"`
	Required                 []string               `json:"required,omitempty"`
	Items                    *Definition            `json:"items,omitempty"`
	Enum                     []json.RawMessage      `json:"enum,omitempty"`
	Const                    json.RawMessage        `json:"const,omitempty"`
	Maximum                  *int                   `json:"maximum,omitempty"`
	Minimum                  *int                   `json:"minimum,omitempty"`
	AdditionalPropertiesBool *bool                  `json:"-"`
	// Handle specific cases where 'additionalProperties' is a boolean
	AdditionalPropertiesSchema *Definition     `json:"-"`
	Type                       json.RawMessage `json:"type,omitempty"`

	// these are used internally for generating FromJson and ToJson
	name       string `json:"-"`
	isRequired bool   `json:"-"`
	// these are added to the auto-generated source following the structs
	helperStructsAndMethods []string `json:"-"`
}

// MarshalJSON handles the serialization of AdditionalProperties which can be a bool or a schema
func (d *Definition) MarshalJSON() ([]byte, error) {
	type Alias Definition
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(d),
	}

	if d.AdditionalPropertiesBool != nil {
		aux.AdditionalProperties = *d.AdditionalPropertiesBool
	} else if d.AdditionalPropertiesSchema != nil {
		aux.AdditionalProperties = d.AdditionalPropertiesSchema
	}

	return json.Marshal(aux)
}
